package asint_asc;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import errors.GestionErroresTiny;

scan with {: 
  return getScanner().next_token(); 
:};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};

	terminal     TERMINACION, ASIGNACION, PUNTO_Y_COMA, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL, 
				 DESIGUAL, IGUAL, CORCHETE_APERTURA, CORCHETE_CIERRE, LITERAL_ENTERO, PUNTO,
				 PARENTESIS_APERTURA, PARENTESIS_CIERRE, COMA, ID_INT, ID_REAL, ID_BOOL, ID_STRING,
				 IDENTIFICADOR, ID_STRUCT, LLAVE_APERTURA, LLAVE_CIERRE, SUMA, RESTA, MULTIPLICACION,
				 DIVISION, MODULO, ID_NOT, INI_NOMBRE, ID_IF, ID_ELSE, ID_PROC, ID_TYPE, ID_CALL, ID_READ, ID_WRITE, 
				 ID_WHILE, ID_NEW, ID_DELETE, ID_NL, REFERENCIA, ID_AND, ID_OR, LITERAL_REAL, LITERAL_CADENA,
				 TRUE, FALSE, ID_NULL, INDIRECCION;

	non terminal  programa, bloque, declaraciones, lista_declaraciones, declaracion, tipo, T0, T1, T2, instrucciones, lista_instrucciones,
				  parametros_formales, lista_parametros_formales_e, lista_parametros_formales, campo, instruccion,
				  parametro_formal, E0, E1, E2, E3, E4, E5, E6, E7, OP1, OP4, OP5, OP6, lista_campos, parametros_reales, 
				  lista_expresiones_e, lista_expresiones, expresion;
				  
	programa ::= bloque:bloq 
		{: RESULT = sem.prog(bloq); :};
	bloque ::= LLAVE_APERTURA declaraciones:decs instrucciones:instrs LLAVE_CIERRE
		{: RESULT = sem.bloq(decs, instrs); :};
	
	declaraciones	::= lista_declaraciones:lista TERMINACION
    	{: RESULT = sem.siDecs(lista); :};
    declaraciones	::=
    	{: RESULT = sem.noDecs(); :};
	
	lista_declaraciones	::= lista_declaraciones:lista PUNTO_Y_COMA declaracion:dec
    	{: RESULT = sem.muchasDecs(lista, dec); :};	
    lista_declaraciones	::= declaracion:dec
    	{: RESULT = sem.unaDec(dec); :};    
    
    declaracion ::= ID_PROC IDENTIFICADOR:id parametros_formales:params bloque:bloq;
   		{: RESULT = sem.decProc(id, params, bloq); :};
    
	declaracion ::= ID_TYPE tipo:t IDENTIFICADOR:id;
		{: RESULT = sem.decType(t, id); :};
	
	declaracion ::= tipo:t IDENTIFICADOR:id;
		{: RESULT = sem.decType(t, id); :};
	
    parametros_formales	::= PARENTESIS_APERTURA lista_parametros_formales_e:lista PARENTESIS_CIERRE
    	{: RESULT = lista; :};
    	
	lista_parametros_formales_e	::= lista_parametros_formales:lista
    	{: RESULT = sem.siParam(lista); :};
    lista_parametros_formales_e	::=
    	{: RESULT = sem.noParam(); :};
    	
    lista_parametros_formales	::= lista_parametros_formales:lista COMA parametro_formal:param
    	{: RESULT = sem.muchosParam(lista, param); :};	
    lista_parametros_formales	::= parametro_formal:param
    	{: RESULT = sem.unParam(param); :};
    
    parametro_formal ::= tipo:t REFERENCIA IDENTIFICADOR:id
    	{: RESULT = sem.paramFormRef(t, id); :};
    parametro_formal ::= tipo:t IDENTIFICADOR:id
    	{: RESULT = sem.paramForm(t, id); :};
    
    tipo ::= T0:t0;
    	{: RESULT = t0 :}
    
    T0 ::= T0:t0 CORCHETE_APERTURA LITERAL_ENTERO:id CORCHETE_CIERRE;
    	{: RESULT = sem.tArray(t0, id) :}
    T0 ::= T1:t1;
    	{: RESULT = t1 :}
    
    T1 ::= INDIRECCION T1:t1;
    	{: RESULT = sem.tPunt(t1) :}
	T1 ::= T2:t2;
		{: RESULT = t2 :}	
		
    T2	::= ID_INT
    	{: RESULT = sem.tInt() :};
    T2	::= ID_REAL
    	{: RESULT = sem.tReal() :};
    T2	::= ID_BOOL
    	{: RESULT = sem.tBool() :};
    T2	::= ID_STRING
    	{: RESULT = sem.tString() :};
    T2	::= IDENTIFICADOR:id
    	{: RESULT = sem.tIden(id) :};
    T2	::= ID_STRUCT LLAVE_APERTURA lista_campos:campos LLAVE_CIERRE
    	{: RESULT = sem.tStruct(campos) :};
    	
    lista_campos ::= lista_campos:lista COMA campo:c
    	{: RESULT = sem.muchosCamps(lista, c); :};
	lista_campos ::= campo:c
		{: RESULT = sem.unCamp(c); :};
	campo ::= tipo:t IDENTIFICADOR:id
		{: RESULT = sem.campo(t, id); :};
    
    instrucciones	::= lista_instrucciones:lista
    	{: RESULT = sem.siInstrs(lista); :};
    instrucciones	::=
    	{: RESULT = sem.noInstrs(); :};
	
	lista_instrucciones	::= lista_instrucciones:lista PUNTO_Y_COMA instruccion:instr
    	{: RESULT = sem.muchasInstrs(lista, instr); :};	
    lista_instrucciones	::= instruccion:instr
    	{: RESULT = sem.unaInstr(instr); :}; 
    
    instruccion ::= INI_NOMBRE expresion:exp;
    	{: RESULT = sem.arrobaInstr(exp); :};
	instruccion ::= ID_CALL IDENTIFICADOR:id parametros_reales:param;
		{: RESULT = sem.procInstr(id, param); :};
	instruccion ::= ID_NL;
		{: RESULT = sem.nlInstr(); :};
	instruccion ::= ID_NEW expresion:exp;
		{: RESULT = sem.newInstr(exp); :};
	instruccion ::= ID_READ expresion:exp;
		{: RESULT = sem.readInstr(exp); :};
	instruccion ::= ID_WRITE expresion:exp;
		{: RESULT = sem.writeInstr(exp); :};
	instruccion ::= ID_DELETE expresion:exp;
		{: RESULT = sem.deleteInstr(exp); :};
	instruccion ::= ID_WHILE expresion:exp bloque:blq;
		{: RESULT = sem.whileInstr(exp, blq); :};
	instruccion ::= ID_IF expresion:exp bloque:blq ID_ELSE bloque:blqh;
		{: RESULT = sem.ifElseInstr(exp, blq, blqh); :};
	instruccion ::= ID_IF expresion bloque;
		{: RESULT = sem.ifInstr(exp, blq); :};
	instruccion ::= bloque:blq;
		{: RESULT = sem.bloqueInstr(blq); :};
		
    parametros_reales	::= PARENTESIS_APERTURA lista_expresiones_e:lista PARENTESIS_CIERRE
    	{: RESULT = lista; :};
    	
	lista_expresiones_e	::= lista_expresiones:lista
    	{: RESULT = sem.siExp(lista); :};
    lista_expresiones_e	::=
    	{: RESULT = sem.noExp(); :};
    	
    lista_expresiones	::= lista_expresiones:lista COMA expresion:exp
    	{: RESULT = sem.muchasExp(lista, exp); :};	
    lista_expresiones	::= expresion:exp
    	{: RESULT = sem.unaExp(exp); :};
    
    expresion ::= E0:e0
    	{: RESULT = e0; :};
    
    E0 ::= E1:e1 ASIGNACION E0:e0;
    	{: RESULT = sem.asignacion(e1, e0); :};
	E0 ::= E1:e1;
		{: RESULT = e1; :};
    
    E1 ::= E1:e1 OP1:op E2:e2;
    	{: RESULT = sem.mkop1(op, e1, e2); :};
	E1 ::= E2:e2;
		{: RESULT = e2; :};
		
    E2	::= E2:e2 SUMA E3:e3
    	{: RESULT = sem.suma(e2, e3); :};
    E2	::= E3:e3a RESTA E3:e3b
    	{: RESULT = sem.resta(e3a, e3b); :};
    E2	::= E3:e3
    	{: RESULT = e3; :};
    	
    E3 ::= E4:e4 ID_AND E3:e3
    	{: RESULT = sem.and(e4, e3); :};
	E3 ::= E4:e41 ID_OR E4:e42
		{: RESULT = sem.or(e41, e42); :};
	E3 ::= E4:e4
		{: RESULT = e4; :};
    	
    E4 ::= E4:e4 OP4:op E5:e5;
    	{: RESULT = sem.mkop4(op, e4, e5); :};
	E4 ::= E5:e5;
		{: RESULT = e5; :};
    	
    E5 ::= OP5:op E5:e5; 
    	{: RESULT = sem.mkop1(op, e5); :};
	E5 ::= E6;	
		{: RESULT = e6; :};
		
    E6	::= E6:e6 OP6:op
    	{: RESULT = sem.mkop(op, e6); :};
    E6	::= E7:e7
    	{: RESULT = e7; :};
    	
    E7 ::= LITERAL_REAL:litR
    	{: RESULT = sem.litReal(litR); :};
	E7 ::= LITERAL_ENTERO:litE
		{: RESULT = sem.litEnt(litE); :};
	E7 ::= IDENTIFICADOR:id
		{: RESULT = sem.iden(id); :};
	E7 ::= LITERAL_CADENA:litC
		{: RESULT = sem.litCad(liC); :};
	E7 ::= TRUE
		{: RESULT = sem._true(); :};
	E7 ::= FALSE
		{: RESULT = sem._false(); :};
	E7 ::= ID_NULL
		{: RESULT = sem._null(); :};
	E7 ::= PARENTESIS_APERTURA E0:e0 PARENTESIS_CIERRE
		{: RESULT = e0; :};
    
    OP1 ::= MENOR:op;
    	{: RESULT = op; :};
    OP1 ::= MAYOR:op;
    	{: RESULT = op; :};
    OP1 ::= MENOR_IGUAL:op;
    	{: RESULT = op; :};
    OP1 ::= MAYOR_IGUAL:op;
    	{: RESULT = op; :};
    OP1 ::= DESIGUAL:op;
    	{: RESULT = op; :};
    OP1 ::= IGUAL:op;
    	{: RESULT = op; :};
    	
    OP4 ::= MULTIPLICACION:op;
    	{: RESULT = op; :};
	OP4 ::= DIVISION:op;
		{: RESULT = op; :};
	OP4 ::= MODULO:op;
		{: RESULT = op; :};	
    OP5	::= RESTA:op
    	{: RESULT = op; :};
    OP5	::= ID_NOT:op
    	{: RESULT = op; :};
    	
    OP6 ::= CORCHETE_APERTURA E0:e0 CORCHETE_CIERRE
    	{: RESULT = e0; :};
	OP6 ::= PUNTO:op IDENTIFICADOR
		{: RESULT = op; :};
	OP6 ::= INDIRECCION:op
		{: RESULT = op; :};